
"int is_inside_circle(int x, int y, int center_x, int center_y, int radius)
{
    int dx ;
    int dy;
    dx = x - center_x;
    dy = y - center_y;
    return (dx * dx + dy * dy) <= (radius * radius);
}

void clear_minimap_area(t_data *game) 
{
    int center_x;
    int center_y;
    int screen_x;
    int screen_y;
    int x;
    int y;
    center_x = WIDTH - MINIMAP_RADIUS - 10;
    center_y = MINIMAP_RADIUS + 10;
    y = 0;
    while (y < MINIMAP_DIAMETER)
    {
        x = 0;
        while (x < MINIMAP_DIAMETER)
        {
            if (is_inside_circle(x, y, MINIMAP_RADIUS, MINIMAP_RADIUS, MINIMAP_RADIUS)) 
            {
                screen_x = center_x - MINIMAP_RADIUS + x;
                screen_y = center_y - MINIMAP_RADIUS + y;
                int pixel_index = (screen_y * game->size_line) + (screen_x * (game->bpp / 8));
                *((unsigned int *)(game->img_data + pixel_index)) = 0x000000; // Black background
            }
            x++;
        }
        y++;
    }
}

void draw_map_tiles(t_data *game) 
{
    int center_x;
    int center_y;
    float player_x;
    float player_y;
    int x;
    int screen_x;
    int screen_y;
    int y;
    center_x = WIDTH - MINIMAP_RADIUS - 10;
    center_y = MINIMAP_RADIUS + 10;
    player_x = game->player.player_x / 30.0f;
    player_y = game->player.player_y / 30.0f;
    y = -MINIMAP_RADIUS;
    while ( y < MINIMAP_RADIUS) 
    {
        x = -MINIMAP_RADIUS;
        while ( x < MINIMAP_RADIUS) 
        {
            if (is_inside_circle(x + MINIMAP_RADIUS, y + MINIMAP_RADIUS, MINIMAP_RADIUS, MINIMAP_RADIUS, MINIMAP_RADIUS - 2))
            {
                int map_x = (int)(player_x + x / (float)TILE_SIZE);
                int map_y = (int)(player_y + y / (float)TILE_SIZE);
                
                unsigned int color;
                if (map_x >= 0 && map_x < game->maze.width && map_y >= 0 && map_y < game->maze.height) 
                {
                  if (game->maze.map[map_y][map_x] == '1') 
                            color = 0x36454F;
                 else 
                            color = 0xADD8E6;
                } 
             else 
                 color = 0x008080;
                screen_x = center_x + x;
                screen_y = center_y + y;
                int pixel_index = (screen_y * game->size_line) + (screen_x * (game->bpp / 8));
                *((unsigned int *)(game->img_data + pixel_index)) = color;
            }
            x++;
        }
        y++;
    }
}

void draw_player_marker(t_data *game) {
    int center_x;
    int center_y;
    int x;
    int y;
    center_x = WIDTH - MINIMAP_RADIUS - 10;
    center_y = MINIMAP_RADIUS + 10;
    y = -PLAYER_MARKER_SIZE;
    while(y <= PLAYER_MARKER_SIZE)
    {
        x = -PLAYER_MARKER_SIZE;
        while( x <= PLAYER_MARKER_SIZE)
        {
            if (x*x + y*y <= PLAYER_MARKER_SIZE*PLAYER_MARKER_SIZE) {
                int screen_x = center_x + x;
                int screen_y = center_y + y;
                int pixel_index = (screen_y * game->size_line) + (screen_x * (game->bpp / 8));
                *((unsigned int *)(game->img_data + pixel_index)) =  0xFFFF00; // Yellow for player
            }
            x++;
        }
        y++;
    }
}



void draw_minimap_border(t_data *game) {
    int center_x;
    int center_y;
    int y;
    int x;
    center_x = WIDTH - MINIMAP_RADIUS - 10;
    center_y = MINIMAP_RADIUS + 10;
    y = -MINIMAP_RADIUS;

    while(y <= MINIMAP_RADIUS)
    {
        x = -MINIMAP_RADIUS;
        while(x <= MINIMAP_RADIUS) 
        {
            if (abs(x*x + y*y - MINIMAP_RADIUS*MINIMAP_RADIUS) < MINIMAP_RADIUS) {
                int screen_x = center_x + x;
                int screen_y = center_y + y;
                int pixel_index = (screen_y * game->size_line) + (screen_x * (game->bpp / 8));
                *((unsigned int *)(game->img_data + pixel_index)) = 0xFFFFFF; //white
            }
            x++;
        }
        y++;
    }
}

int render_minimap(t_data *game) 
{
    clear_minimap_area(game);
    draw_map_tiles(game);
    draw_player_marker(game);
    draw_minimap_border(game);
    return 0;
}

void render_3d_projection(t_data *game, float distance, int ray_index, int tile_size)
{
    int texture_y;
    int wall_height;
    int draw_start;
    int draw_end;
    int texture_index;
    int *texture_buffer;
    int color;
    int y;
    float step;
    float texture_pos;
    int pixel_index;
    int texture_width;
    int texture_x;
    float wall_x;
    if (distance <= 0) distance = 0.1;
     wall_height = (int)(tile_size * HEIGHT / distance);
     draw_start = HEIGHT / 2 - wall_height / 2 ;
    if (draw_start < 0) draw_start = 0;
     draw_end = wall_height / 2 + HEIGHT / 2;
    if (draw_end >= HEIGHT) draw_end = HEIGHT - 1;

    if (game->vector.side == 0)
        wall_x = game->player.player_y / tile_size + distance * game->vector.ray_dir_y / tile_size;
    else
        wall_x = game->player.player_x / tile_size + distance * game->vector.ray_dir_x / tile_size;
    wall_x -= floor(wall_x);

    if (game->vector.side == 0)
    {

        if(game->vector.ray_dir_x > 0)
             texture_index = 0;
        else
            texture_index = 1;
    } 
    else
    {
         if(game->vector.ray_dir_y > 0) 
            texture_index = 2;
        else
            texture_index =  3;
    }
    texture_buffer = game->walls->scale[texture_index];
    texture_width = game->walls->width[texture_index];
    texture_x = (int)(wall_x * (float)texture_width);
    if ((game->vector.side == 0 && game->vector.ray_dir_x > 0) ||
        (game->vector.side == 1 && game->vector.ray_dir_y < 0))
        texture_x = texture_width - texture_x - 1;
    step = 1.0 * game->walls->height[texture_index] / wall_height;
    texture_pos = (draw_start - HEIGHT / 2 + wall_height / 2) * step;
    y = draw_start;
    while(y < draw_end)
    {
         texture_y = (int)texture_pos % (game->walls->height[texture_index] - 1); 
        texture_pos += step; 
        color = texture_buffer[texture_y * texture_width + texture_x]; 
        
        if (game->vector.side == 1)
            color = (color >> 1) & 8355711;
         pixel_index = (y * WIDTH + ray_index) * (game->bpp / 8);
        *((unsigned int *)(game->img_data + pixel_index)) = color;
        y++;
    }
}


void render_color(t_data *game) 
{
    int draw_end;
    int y;
    int x;
    int pixel_index;

    draw_end = HEIGHT / 2;
    if (draw_end >= HEIGHT) draw_end = HEIGHT - 1;
    y = 0;
    while( y < draw_end) 
    {
        x = 0;
         while(x < WIDTH)
         {

        pixel_index = (y * WIDTH + x) * (game->bpp / 8);
         *((unsigned int *)(game->img_data + pixel_index)) = game->maze.c;
         x++;
         }
    y++;
    }
}

void render_flor(t_data *game) 
{
    int draw_end;
    int y;
    int x;
    int pixel_index;

    draw_end = HEIGHT ;
    if (draw_end >= HEIGHT) draw_end = HEIGHT - 1;
    y =  HEIGHT / 2;
    while( y < draw_end) 
    {
        x = 0;
         while(x < WIDTH)
         {

        pixel_index = (y * WIDTH + x) * (game->bpp / 8);
         *((unsigned int *)(game->img_data + pixel_index)) = game->maze.f;
         x++;
         }
    y++;
    }
}

void cast_ray_dda(t_data *game, float angle, int ray_index, int tile_size) 
{
    game->vector.map_x = (int)(game->player.player_x / tile_size);
    game->vector.map_y = (int)(game->player.player_y / tile_size);
    game->vector.ray_dir_x = cosf(angle);
    game->vector.ray_dir_y = sinf(angle);

    game->vector.delta_dist_x = fabs(1 / game->vector.ray_dir_x);
    game->vector.delta_dist_y = fabs(1 / game->vector.ray_dir_y);
    game->vector.hit = 0;

    if (game->vector.ray_dir_x < 0) 
    {
        game->vector.step_x = -1;
        game->vector.side_dist_x = (game->player.player_x / tile_size - game->vector.map_x) * game->vector.delta_dist_x;
    } 
    else 
    {
        game->vector.step_x = 1;
        game->vector.side_dist_x = (game->vector.map_x + 1.0 - game->player.player_x / tile_size) * game->vector.delta_dist_x;
    }

    if (game->vector.ray_dir_y < 0) 
    {
        game->vector.step_y = -1;
        game->vector.side_dist_y = (game->player.player_y / tile_size - game->vector.map_y) * game->vector.delta_dist_y;
    }
    else 
    {
        game->vector.step_y = 1;
        game->vector.side_dist_y = (game->vector.map_y + 1.0 - game->player.player_y / tile_size) * game->vector.delta_dist_y;
    }

    while (game->vector.hit == 0) 
    {
        if (game->vector.side_dist_x < game->vector.side_dist_y) 
        {
            game->vector.side_dist_x += game->vector.delta_dist_x;
            game->vector.map_x += game->vector.step_x;
            game->vector.side = 0;
        } 
        else
        {
            game->vector.side_dist_y += game->vector.delta_dist_y;
            game->vector.map_y += game->vector.step_y;
            game->vector.side = 1;
        }

        if (game->vector.map_y < 0 || game->vector.map_y >= game->maze.height ||
            game->vector.map_x < 0 || game->vector.map_x >= game->maze.width)
            return; // Out of bounds, stop processing

        if (game->maze.map[game->vector.map_y][game->vector.map_x] == '1')
            game->vector.hit = 1;
    }

    if (game->vector.side == 0)
    {
        game->vector.perp_wall_dist = (game->vector.map_x - game->player.player_x / tile_size + (1 - game->vector.step_x) / 2) / game->vector.ray_dir_x;
    } 
    else 
    {
        game->vector.perp_wall_dist = (game->vector.map_y - game->player.player_y / tile_size + (1 - game->vector.step_y) / 2) / game->vector.ray_dir_y;
    }

    render_3d_projection(game, game->vector.perp_wall_dist * tile_size, ray_index, tile_size);
}

void handle_collision(t_data *game, float player_angle, float collision_angle)
{
    float angle_diff;
    angle_diff  = fmodf(collision_angle - player_angle + PI * 3, PI * 2) - PI;
    
    if (angle_diff > 0) 
        game->player.angle -= 0.02;
    else 
        game->player.angle += 0.02;
    
    game->player.angle = fmodf(game->player.angle + PI * 2, PI * 2);
}

int key_hook(int keycode, t_data *game) 
{
    int tile_size;
    int map_x;
    int map_y;
    tile_size = 30;
    if (keycode == 65361)
   game->player.angle -= ROT_SPEED;
    if (keycode == 65363) 
        game->player.angle += ROT_SPEED;
 
    if (keycode == 65362) 
    {
        map_x = (int)((game->player.player_x + cosf(game->player.angle) * MOVE_SPEED) / tile_size);
        map_y = (int)((game->player.player_y + sinf(game->player.angle) * MOVE_SPEED) / tile_size);
        if (game->maze.map[map_y][map_x] != '1') 
        {
            game->player.player_x += cosf(game->player.angle) * MOVE_SPEED;
            game->player.player_y += sinf(game->player.angle) * MOVE_SPEED;
        }
       else
        {

           float collision_angle = atan2f(map_y * tile_size + tile_size / 2 - game->player.player_y,
                                           map_x * tile_size + tile_size / 2 - game->player.player_x);
            handle_collision(game, game->player.angle, collision_angle);
        }
    }
    if (keycode == 65364)
    {
        map_x = (int)((game->player.player_x - cosf(game->player.angle) * MOVE_SPEED) / tile_size);
        map_y = (int)((game->player.player_y - sinf(game->player.angle) * MOVE_SPEED) / tile_size);
        if (game->maze.map[map_y][map_x] != '1') 
        {
            game->player.player_x -= cosf(game->player.angle) * MOVE_SPEED;
            game->player.player_y -= sinf(game->player.angle) * MOVE_SPEED;
        }
    }
    if(keycode == 32)
    {
         game->hide_mouse = 1;
        mlx_mouse_show(game->mlx, game->win);
    }
    
    if (keycode == 65307) 
    {  
        mlx_destroy_window(game->mlx, game->win);
        exit(0);
    }
    
    return (0);
}" "void	init_data(t_data *data)
{
	data->mlx = mlx_init();
	data->win = mlx_new_window(data->mlx, WIDTH, HEIGHT, "Cub3D");
	data->maze.map = NULL;
	data->maze.no = NULL;
	data->maze.so = NULL;
	data->maze.we = NULL;
	data->maze.ea = NULL;
	data->maze.f = 0;
	data->maze.c = 0;
	data->maze.height = 0;
	data->player.angle = 0;
	data->player.fov = PI / 3;
	data->player.player_x = 0;
    data->player.player_y = 0;
    data->player.x = 0;
    data->player.y = 0;
    data->x_mouse_prev = 0;
    data->hide_mouse = 0;
    data->enemy.x = 0;
    data->enemy.y = 0;
    data->enemy.enemy_index = 0;
    data->enemy.x_enemy = 0;
    data->enemy.y_enemy = 0;
}

int update(t_data *game)
{
    int x = 0;
    int tile_size = 30;
    float ray_angle;

    memset(game->img_data, 0, WIDTH * HEIGHT * (game->bpp / 8));

    render_color(game);
    render_flor(game);
    while (x < WIDTH)
    {
        ray_angle = game->player.angle + atanf((x - WIDTH / 2.0) / (WIDTH / 2.0 / tanf(game->player.fov / 2.0)));
        cast_ray_dda(game, ray_angle, x, tile_size);
        x++;
    }
    render_minimap(game);
    render_enemy(game);
    mlx_put_image_to_window(game->mlx, game->win, game->img, 0, 0);
    return 0;
}
int mouse_hook(int x_mouse, int y_mouse, t_data *game)
{
    (void)y_mouse;
    
      if (game->player.angle >= 2 * PI)
            game->player.angle -= 2 * PI;
     if (game->player.angle < 0)
            game->player.angle += 2 * PI;
    if (x_mouse > game->x_mouse_prev)
        game->player.angle += 0.05;
    else if (x_mouse < game->x_mouse_prev)
        game->player.angle -= 0.05;
    if(game->hide_mouse == 0)
        mlx_mouse_move(game->mlx, game->win, WIDTH / 2, HEIGHT / 2);
    return 0;
}
int mouse_hide(t_data *game)
{
    game->hide_mouse = 0;
    mlx_mouse_hide(game->mlx, game->win);
    return 0;
}


int ft_exit(t_data *game)
{
    mlx_destroy_window(game->mlx, game->win);
    exit(0);
    return 0;
}

int	main(int ac, char **av)
{
	t_data	data;
	int tile_size;

	if (ac == 2)
	{
		init_data(&data);
		if (parse_cub(av[1], &data) && print_error("Error \n"))
			        return (1);
        data.walls = malloc(sizeof(t_images));
        ft_bzero(data.walls, sizeof(t_images));

       data.textures = malloc(sizeof(t_textures));
        ft_bzero(data.textures, sizeof(t_textures));

        tile_size = 30;
        data.player.player_x = (data.player.x * tile_size) + (tile_size / 2);
        data.player.player_y = (data.player.y * tile_size) + (tile_size / 2);
        data.x_mouse_prev = WIDTH / 2; 
        init_walls(&data);
        data.img = mlx_new_image(data.mlx, WIDTH, HEIGHT);
        data.img_data = mlx_get_data_addr(data.img, &data.bpp, &data.size_line, &data.endian);
        update(&data);
    mlx_hook(data.win, 02, 1L << 0, key_hook, &data);
    mlx_hook(data.win, 6, 1L<<6, mouse_hook, &data);
    mlx_hook(data.win, 7, 1L << 4, mouse_hide, &data);
    mlx_hook(data.win, 17, 0, ft_exit, &data);
    mlx_mouse_hide(data.mlx, data.win);
    mlx_loop_hook(data.mlx, update, &data);
    mlx_loop(data.mlx);
    mlx_destroy_image(data.mlx, data.img);
    mlx_mouse_show(data.mlx, data.win);
      free(data.maze.map);
	}
	else
		print_error("Error: invalid number of arguments\n");
	return (0);
}" "#ifndef CUB3D_H
# define CUB3D_H

# include "gnl/get_next_line.h"
# include "libft/libft.h"
# include <errno.h>
# include <fcntl.h>
# include <limits.h>
# include <math.h>
# include <mlx.h>
# include <stdio.h>
# include <stdlib.h>
# include <string.h>
# include <sys/time.h>
# include <unistd.h>

# define WIDTH 1080
# define HEIGHT 1000
# define PI 3.14159265359
# define UP 1
# define DOWN 2
# define LEFT 3
# define RIGHT 4
# define MOVE_SPEED 5.0
# define ROT_SPEED 0.1
#define MINIMAP_RADIUS 100
#define MINIMAP_DIAMETER (MINIMAP_RADIUS * 2)
#define TILE_SIZE 10
#define PLAYER_MARKER_SIZE 4

/***************ENEMY*********************/
# define ENEMY0 "textures/frame1_xpm/enemy_0.xpm"
# define ENEMY1 "textures/frame1_xpm/enemy_1.xpm"
# define ENEMY2 "textures/frame1_xpm/enemy_2.xpm"
# define ENEMY3 "textures/frame1_xpm/enemy_3.xpm"
# define ENEMY4 "textures/frame1_xpm/enemy_4.xpm"
# define ENEMY5 "textures/frame1_xpm/enemy_5.xpm"
# define ENEMY6 "textures/frame1_xpm/enemy_6.xpm"
# define ENEMY7 "textures/frame1_xpm/enemy_7.xpm"
# define ENEMY8 "textures/frame1_xpm/enemy_8.xpm"
# define ENEMY9 "textures/frame1_xpm/enemy_9.xpm"
# define ENEMY10 "textures/frame1_xpm/enemy_10.xpm"
# define ENEMY11 "textures/frame1_xpm/enemy_11.xpm"
# define ENEMY12 "textures/frame1_xpm/enemy_12.xpm"
# define ENEMY13 "textures/frame1_xpm/enemy_13.xpm"
# define ENEMY14 "textures/frame1_xpm/enemy_14.xpm"
# define ENEMY15 "textures/frame1_xpm/enemy_15.xpm"
/****************************************/

typedef struct s_textures
{
	void *images[16];
	int *addr[16];
	int *scale_enemy[16];
	int bpp[16];
	int size_line[16];
	int endian[16];
	int width[16];
	int height[16];
}				t_textures;
typedef struct s_enemy
{
	int enemy_index;
	int x;
	int y;
	int x_enemy;
	int y_enemy;
} t_enemy;
typedef struct s_player
{
	int			x;
	int			y;
	// double		dir_x;
	// double		dir_y;
	float		angle;
	double		fov;
	double		player_x;
	double		player_y;
}				t_player;

// typedef struct s_mini_map
// {
// 	void		*img;
// 	char		*img_data;
// 	int			bpp;
// 	int			size_line;
// 	int			endian;
// }				t_mini_map;

typedef struct s_map
{
	char		**map;
	char		*no;
	char		*so;
	char		*we;
	char		*ea;
	int			f;
	int			c;
	int			height;
	int			width;
}				t_map;

typedef struct s_vec
{
	int			x;
	int			y;
	int			map_x;
	int			map_y;
	int			step_x;
	int			step_y;
	double		side_dist_x;
	double		side_dist_y;
	double		ray_dir_x;
	double		ray_dir_y;
	int			hit;
	int			side;
	double		delta_dist_x;
	double		delta_dist_y;
	double		perp_wall_dist;
}				t_vec;

typedef struct s_images
{
	void		*images[4];
	int			*addr[4];
	int			*scale[4];
	int			width[4];
	int			height[4];
	int			bpp[4];
	int			size_line[4];
	int			endian[4];
}				t_images;

typedef struct s_data
{
	void		*mlx;
	void		*win;
	t_images	*walls;
	t_map		maze;
	t_player	player;
	t_vec		vector;
	t_enemy		enemy;
	t_textures	*textures;
	// t_mini_map	mini_map;
	void		*img;
	char		*img_data;
	int			bpp;
	int			size_line;
	int			endian;
	int			hide_mouse;
	int			player_face;
	int			x_mouse_prev;

}				t_data;

int				update(t_data *data);
void			render_flor(t_data *game);
void			render_color(t_data *game);
void			render_3d_projection(t_data *game, float distance,
					int ray_index, int tile_size);
void			cast_ray_dda(t_data *game, float angle, int ray_index,
					int tile_size);
int				key_hook(int keycode, t_data *game);
int				check_is_map_valid(t_data *prog, char *file);
int				validate_walls(t_map *maze);
int				check_empty(t_map *maze);
int				print_error(char *str);
void			init_textures(t_data *game);
void			texture_address(t_data *game);
int				map_copy(t_map *prog, char *file);
int				check_textures(t_data *prog);
int				my_strchr(char *str, char *c);
int				check_extension(char *file);
int				free_line(char *line);
int				check_conditions(char ch, int count);
int				parse_cub(char *file, t_data *prog);
int				is_skip(char *line, int flag);
int				should_skip(char *line);
int				check_valid_char(char c, int flag);
int 			render_minimap(t_data *game);
void			init_walls(t_data *game);
void			*file_to_img(t_data *data, char *img_path, int *w, int *h);
void			render_enemy(t_data *game);
int				is_inside_circle(int x, int y, int center_x, int center_y, int radius);
// void			draw_map(t_data *game, int tile_size);

#endif" "111111111111111111111111111111111111111111111111111111111111111
100000000000000000000000000000000000000000000000000000000000001
100000000001010100000000000000000000000000000000000000000000001
100010000000000000000000000000000000000000000000000000000000001
100000000000000000000000000001000000000000000000000000000000001
100010000000000000000000W000000000000000000X0000000000000000001
100000000000000000000000000000000000000000000000000000000000001
100000000000000000000000000000000000000000000000000000000000001
100000000000000000000000000000000000000000000000000000000000001
100000000000000000000000000000000000000000000000000000000000001
100000000000000000000000000000000000000000000000000000000000001
111111111111111111111111111111111111111111111111111111111111111 " 
this is my project now i want render my 
enemy in my 3d project but i don't know how i can do it 